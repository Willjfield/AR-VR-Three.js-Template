<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>mask_template</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
      
  </head>
  <body>    
      <script type="text/javascript" src="/js/stats.min.js"></script>

      <div id="render-canvas"> </div>

      <!-- cam -->
      <p id="errorMessage" style="display:none"></p>
      <video id="video" autoplay loop width="480" height="320" style="display:none"></video>  
      <canvas id="videoImage" width="480" height="320" style="display:none">

      <!-- style="z-index:10000000001; position:absolute; left:0px; top:0px; display:none;" -->

      <script type="text/javascript">
        var video = document.getElementById('video');
        var videoImage = document.getElementById('videoImage');
        var videoTexture;
        var scene, camera, renderer;
        var videoImageContext;
        var videoWidth = 480, videoHeight = 320;
        var container;
        var effect;
        var movieMaterial, movieGeometry, movieScreen;
       
        // ref: https://github.com/samdutton/simpl/blob/master/getusermedia/sources/js/main.js
        var audioSource = null, videoSource = null, camUserID = null, camEnvironmentID = null;
        var mediaConstraints = {};

 


        
        function gotSources(sourceInfos) {
          for (var i = 0; i !== sourceInfos.length; ++i) {
              var sourceInfo = sourceInfos[i];
              if (sourceInfo.kind === 'video') {
                if (sourceInfo.facing === 'user') camUserID = sourceInfo.id;
                else if (sourceInfo.facing === 'environment') {
                  camEnvironmentID = sourceInfo.id;
                  mediaConstraints = {
                  video: {
                    mandatory: {
                        maxWidth: 480,
                        maxHeight: 320,
                        minWidth: 480,
                        minHeight: 320
                      },
                    optional: [{sourceId: camEnvironmentID}]
                  }
                };
                navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
                }
                else {
                  camEnvironmentID = sourceInfo.id;
                  mediaConstraints = {
                  video: {
                    mandatory: {
                        maxWidth: 480,
                        maxHeight: 320,
                        minWidth: 480,
                        minHeight: 320
                      },
                    optional: [{sourceId: camEnvironmentID}]
                  }
                };
                navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
                }
              } 
          }
        }
        // for selecting back camera of phone
        if (typeof MediaStreamTrack.getSources === 'undefined'){
          alert('This browser does not support MediaStreamTrack.\n\nTry Chrome Canary.');
        } else {
          MediaStreamTrack.getSources(gotSources);
        }
        navigator.getUserMedia = navigator.getUserMedia || 
          navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

        function successCallback(stream) {
          // window.stream = stream; // make stream available to console

          video.src = window.URL.createObjectURL(stream);
          video.play();

          init ();

          
          
        }


        function errorCallback(error){
          var msg = 'No camera available.';
          if (error.code == 1) 
          {   msg = 'User denied access to use camera.';   }
          document.getElementById('errorMessage').textContent = msg;
          console.log('navigator.getUserMedia error: ', error);
        }




        function init () {           
            alert ('init');

            container = document.getElementById('render-canvas');

            renderer = new THREE.WebGLRenderer({
              antialias: true, 
              alpha: true
            });
            renderer.setClearColor(0x000000, 1);
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);

            effect = new THREE.StereoEffect( renderer );
            effect.separation = 0.2;
            effect.targetDistance = 50;
            effect.setSize( window.innerWidth, window.innerHeight);

            

            videoImageContext = videoImage.getContext('2d');
            videoImageContext.fillStyle = '0xffffff';
            videoImageContext.fillRect(0,0,videoWidth, videoHeight);

            videoTexture = new THREE.Texture(videoImage);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.wrapS = videoTexture.wrapT = THREE.ClampToEdgeWrapping;
            videoTexture.needsUpdate = true;
            
            movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true, side:THREE.DoubleSide } );
            // the geometry on which the movie will be displayed;
            //      movie image will be scaled to fit these dimensions.
            movieGeometry = new THREE.PlaneBufferGeometry( 240, 100, 4, 4 );
            movieScreen = new THREE.Mesh( movieGeometry, movieMaterial );
            movieScreen.position.set(0,50,0);

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            camera.position.set(0,37,200);

            

            scene = new THREE.Scene();

            scene.add(movieScreen);

            
            //camera.lookAt(movieScreen.position);

            // CONTROLS
            //controls = new THREE.DeviceControls(camera, true);
            //scene.add( controls.getObject() );

            // canvas contents will be used for a texture
            // var texture1 = new THREE.Texture(canvasMain);
            //canvas.hidden = true; 

            // texture1.needsUpdate = true;

            
            
            
            /*
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            stats.domElement.style.zIndex = 100;
            container.appendChild( stats.domElement );
            */
            
            animate ();

        }
        

        function animate() {
            requestAnimationFrame( animate );
            update();
            render();
        }

        function update() { 
  
        // WEB_CAM
          if(video.readyState === video.HAVE_ENOUGH_DATA){
            videoImageContext.drawImage(video, 0, 0);

                  // update texture for 3D
            if(videoTexture){
              videoTexture.flipY = true;
              videoTexture.needsUpdate = true;
            }
          } 
        }

        function render() { 
          // renderer.render( scene, camera );
          effect.render( scene, camera );
        }


        

        

        
        /*
        var isStreaming = false;
        //var grey = document.getElementById('grey');
        var context = canvas.getContext('2d');
        var w = 600;
        var h = 420;
        //var greyscale = true;

        video.addEventListener('canplay', function(e) {
           if (!isStreaming) {
              // videoWidth isn't always set correctly in all browsers
              if (video.videoWidth > 0) h = video.videoHeight / (video.videoWidth / w);
              canvas.setAttribute('width', w);
              canvas.setAttribute('height', h);
              // Reverse the canvas image
              context.translate(w, 0);
              context.scale(-1, 1);
              isStreaming = true;
           }
        }, false);

        video.addEventListener('play', function() {
           // Every 33 milliseconds copy the video image to the canvas
           setInterval(function() {
              if (video.paused || video.ended) return;
              context.fillRect(0, 0, w, h);
              context.drawImage(video, 0, 0, w, h);
              //if (greyscale) goingGrey();
              // init MASK world
              init();
              animate ();
           }, 33);
        }, false);


        
        var goingGrey = function() {
           var imageData = context.getImageData(0, 0, w, h);
           var data = imageData.data;
           for (var i = 0; i < data.length; i += 4) {
              var bright = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
              data[i] = bright;
              data[i + 1] = bright;
              data[i + 2] = bright;
           }
           context.putImageData(imageData, 0, 0);
        }
        */
        


 


    
      </script>

      <script src="/js/StereoEffect.js"></script>
      <!--<script src="/js/DeviceControls.js"></script> -->
      <!-- <script type="text/javascript" src="js/Detector.js"></script> -->
      <script type="text/javascript" src="/js/CanvasRenderer.js"></script>
      <script type="text/javascript" src="/js/Projector.js"></script>
      <!-- <script type="text/javascript" src="js/lib/tween.min.js"></script> -->
      
      <script type="text/javascript" src="/js/three.min.js"></script>
      


  </body>
</html>